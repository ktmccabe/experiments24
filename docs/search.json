[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Experiments 2024",
    "section": "",
    "text": "Course Notes\nThis document will include important links and course notes for Experimental Methods in Political Science."
  },
  {
    "objectID": "index.html#getting-set-up-in-r",
    "href": "index.html#getting-set-up-in-r",
    "title": "Experiments 2024",
    "section": "Getting Set Up in R",
    "text": "Getting Set Up in R\nGoal\nBy the end of the first week of the course, you will want to have R and RStudio installed on your computer (both free), feel comfortable using R as a calculator, and making documents using the R Markdown file type within RStudio.\nR is an application that processes the R programming language. RStudio is also an application, which serves as a user interface that makes working in R easier. We will primarily open and use RStudio to work with R.\nIn other classes, you may come across Stata, SPSS, Excel, or SAS, which are programs that also conduct data analysis. R has the advantage of being free and open-source. Even after you leave the university setting, you will be able to use R/RStudio for free. As an open-source program, it is very flexible, and a community of active R/RStudio users is constantly adding to and improving the program. You might also encounter the Python language at some point. R and Python have similarities, and learning R can also make learning Python easier down the road.\nR and RStudio Installation\n\nThis video from Professor Christopher Bail explains why many social scientists use R and describes the R and RStudio installation process. This involves\n\nGoing to cran, select the link that matches your operating system, and then follow the installation instructions, and\nVisiting RStudio and follow the download and installation instructions. R is the statistical software and programming language used for analysis. RStudio provides a convenient user interface for running R code."
  },
  {
    "objectID": "index.html#open-r-script-in-rstudio",
    "href": "index.html#open-r-script-in-rstudio",
    "title": "Experiments 2024",
    "section": "Open R Script in RStudio",
    "text": "Open R Script in RStudio\nThis next section provides a few notes on using R and RStudio now that you have installed it. In this section, we cover the following materials:\n\nUsing R as a calculator and assigning objects using &lt;-\nSetting your working directory and the setwd() function.\nCreating and saving an R script (.R file)\nCreating, saving, and compiling an R Markdown document (.Rmd) into an html document (.html)\n\nRStudio is an open-source and free program that greatly facilitates the use of R, especially for users new to programming. Once you have downloaded and installed R and RStudio, to work in R, all you need to do now is open RStudio (it will open R). It should look like this, though your version numbers will be different:\n\nNote: The first time you open RStudio, you likely only have the three windows above. We will want to create a fourth window by opening an R script to create the fourth window.\n\nTo do this, in RStudio, click on File -&gt; New -&gt; R script in your computer’s toolbar. This will open a blank document for text editing in the upper left of the RStudio window. We will return to this window in a moment.\n\nYou can alternatively click on the green + sign indicator in the top-left corner of the RStudio window, which should give you the option to create a new R script document.\n\n\nNow you should have something that looks like this:\n\n\nThe upper-left window has our .R script document that will contain code.\nThe lower-left window is the console. This will show the output of the code we run. We will also be able to type directly in the console.\nThe upper-right window shows the environment (and other tabs, such as the history of commands). When we load and store data in RStudio, we will see a summary of that in the environment.\nThe lower-right window will enable us to view plots and search help files, among other things.\n\n\nUsing R as a Calculator\nThe bottom left window in your RStudio is the Console. You can type in this window to use R as a calculator or to try out commands. It will show the raw output of any commands you type. For example, we can try to use R as a calculator. Type the following in the Console (the bottom left window) and hit “enter” or “return” on your keyboard:\n\n5 + 3\n\n[1] 8\n\n5 - 3\n\n[1] 2\n\n5^2\n\n[1] 25\n\n5 * 3\n\n[1] 15\n\n5/3\n\n[1] 1.666667\n\n(5 + 3) * 2\n\n[1] 16\n\n\nAgain, in the other RStudio windows, the upper right will show a history of commands that you have sent from the text editor to the R console, along with other items. The lower right will show graphs, help documents and other features. These will be useful later in the course.\n\n\nWorking in an R Script\nEarlier, I asked you to open an R script in the upper left window by doing File, then New File, then R Script. Let’s go back to working in that window.\nSet your working directory setwd()\nMany times you work in RStudio, the first thing you will do is set your working directory. This is a designated folder in your computer where you will save your R scripts and datasets.\nThere are many ways to do this.\n\nAn easy way is to go to Session -&gt; Set Working Directory -&gt; Choose Directory. I suggest choosing a folder in your computer that you can easily find and that you will routinely use for this class. Go ahead and create/select it.\nNote: when you selected your directory, code came out in the bottom left Console window. This is the setwd() command which can also be used directly to set your working directory in the future.\nIf you aren’t sure where your directory has been set, you can also type getwd() in your Console. Try it now\n\n\n## Example of where my directory was\ngetwd()\n\n[1] \"/Users/ktmccabe/Dropbox/GitHub2/experiments24\"\n\n\nIf I want to change the working directory, I can go to the top toolbar of my computer and use Session -&gt; Set Working Directory -&gt; Choose Directory or just type my file pathway using the setwd() below:\n\n## Example of setting the working directory using setwd().\n## Your computer will have your own file path.\nsetwd(\"/Users/ktmccabe/Dropbox/Rutgers Teaching/\")\n\n\n\nSaving the R Script\nLet’s now save our R script to our working directory and give it an informative name. To do so, go to File, then Save As, make sure you are in the same folder on your computer as the folder you chose for your working directory.\nGive the file an informative name, such as: “McCabeWeek1.R”. Note: all of your R scripts will have the .R extension.\n\n\nAnnotating your R script\nNow that we have saved our R script, let’s work inside of it. Remember, we are in the top-left RStudio window now.\n\nJust like the beginning of a paper, you will want to title your R script. In R, any line that you start with a # will not be treated as a programming command. You can use this to your advantage to write titles/comments– annotations that explain what your code is doing. Below is a screenshot example of a template R script.\nYou can specify your working directory at the top, too. Add your own filepath inside setwd()\n\n\n\nThen you can start answering problems in the rest of the script.\nThink of the R script as where you write the final draft of your paper. In the Console (the bottom-left window), you can mess around and try different things, like you might when you are taking notes or outlining an essay. Then, write the final programming steps that lead you to your answer in the R script. For example, if I wanted to add 5 + 3, I might try different ways of typing it in the Console, and then when I found out 5 + 3 is the right approach, I would type that into my script.\n\n\n\nRunning Commands in your R script\nThe last thing we will note in this section is how to execute commands in your R script.\nTo run / execute a command in your R script (the upper left window), you can\n\nHighlight the code you want to run, and then hold down “command + return” on a Mac or “control + enter” on Windows\nPlace your cursor at the end of the line of code (far right), and hit “command + return” on a Mac or “control + return” on Windows, or\nDo 1 or 2, but instead of using the keyboard to execute the commands, click “Run” in the top right corner of the upper-left window.\n\nTry it: Type 5 + 3 in the R script. Then, try to execute 5 + 3. It should look something like this:\n\nAfter you executed the code, you should see it pop out in your Console:\n\n5 + 3\n\n[1] 8\n\n\n\nNote: The symbol # also allows for annotation behind commands or on a separate line. Everything that follows # will be ignored by R. You can annotate your own code so that you and others can understand what each part of the code is designed to do.\n\n## Example\nsum53 &lt;- 5 + 3 # example of assigning an addition calculation\n\n\n\nObjects\nSometimes we will want to store our calculations as “objects” in R. We use &lt;- to assign objects by placing it to the left of what we want to store. For example, let’s store the calculation 5 + 3 as an object named sum53:\n\nsum53 &lt;- 5 + 3\n\nAfter we execute this code, sum53 now stores the calculation. This means, that if we execute a line of code that just has sum53, it will output 8. Try it:\n\nsum53\n\n[1] 8\n\n\nNow we no longer have to type 5 + 3, we can just type sum53. For example, let’s say we wanted to subtract 2 from this calculation. We could do:\n\nsum53 - 2\n\n[1] 6\n\n\nLet’s say we wanted to divide two stored calculations:\n\nten &lt;- 5 + 5\ntwo &lt;- 1 + 1\nten / two\n\n[1] 5\n\n\nThe information stored does not have to be numeric. For example, it can be a word, or what we would call a character string, in which case you need to use quotation marks.\n\nmccabe &lt;- \"professor for this course\"\nmccabe\n\n[1] \"professor for this course\"\n\n\nNote: Object names cannot begin with numbers and no spacing is allowed. Avoid using special characters such as % and $, which have specific meanings in R. Finally, use concise and intuitive object names.\n\nGOOD CODE: practice.calc &lt;- 5 + 3\nBAD CODE: meaningless.and.unnecessarily.long.name &lt;- 5 + 3\n\nWhile these are simple examples, we will use objects all the time for more complicated things to store (e.g., like full datasets!) throughout the course.\nWe can also store an array or “vector” of information using c()\n\nsomenumbers &lt;- c(3, 6, 8, 9)\nsomenumbers\n\n[1] 3 6 8 9\n\n\nImportance of Clean Code\nIdeally, when you are done with your R script, you should be able to highlight the entire script and execute it without generating any error messages. This means your code is clean. Code with typos in it may generate a red error message in the Console upon execution. This can happen when there are typos or commands are misused.\nFor example, R is case sensitive. Let’s say we assigned our object like before:\n\nsum53 &lt;- 5 + 3\n\nHowever, when we went to execute sum53, we accidentally typed Sum53:\n\nSum53\n\nError in eval(expr, envir, enclos): object 'Sum53' not found\n\n\nOnly certain types of objects can be used in mathematical calculations. Let’s say we tried to divide mccabe by 2:\n\nmccabe / 2\n\nError in mccabe/2: non-numeric argument to binary operator\n\n\nA big part of learning to use R will be learning how to troubleshoot and detect typos in your code that generate error messages."
  },
  {
    "objectID": "index.html#r-markdown",
    "href": "index.html#r-markdown",
    "title": "Experiments 2024",
    "section": "R Markdown",
    "text": "R Markdown\nAn R Markdown document, which you can also create in RStudio, allows you to weave together regular text, R code, and the output of R code in the same document. This can be very convenient when conducting data analysis because it allows you more space to explain what you are doing in each step. We will use it as an effective platform for writing up problem sets.\nR Markdown documents can be “compiled” into html, pdf, or docx documents by clicking the Knit button on top of the upper-left window. Below is an example of what a compiled html file looks like.\n\nNote that the image has both written text and a gray chunk, within which there is some R code, as well as the output of the R code (e.g., the number 8 and the image of the histogram plot. \n\nWe say this is a “compiled” RMarkdown document because it differs from the raw version of the file, which is a .Rmd file format. Below is an example of what the raw .Rmd version looks like, compared to the compiled html version.\n \n\nGetting started with RMarkdown\nJust like with a regular R script, to work in R Markdown, you will open up RStudio.\n\nFor additional support beyond the notes below, you can also follow the materials provided by RStudio for getting started with R Markdown https://rmarkdown.rstudio.com/lesson-1.html.\n\nThe first time you will be working in R Markdown, you will want to install two packages: rmarkdown and knitr. You can do this in the Console window in RStudio (remember the lower-left window!).\nType the following into the Console window and hit enter/return.\n\ninstall.packages(\"rmarkdown\")\ninstall.packages(\"knitr\")\n\nOnce you have those installed, now, each time you want to create an R Markdown document, you will open up a .Rmd R Markdown file and get to work.\n\nGo to File -&gt; New File -&gt; R Markdown in RStudio\n\nAlternatively, you can click the green + symbol at the top left of your RStudio window\n\nThis should open up a window with several options, similar to the image below\n\nCreate an informative title and change the author name to match your own\nFor now, we will keep the file type as html. In the future, you can create pdf or .doc documents. However, these require additional programs installed on your computer, which we will not cover in the course.\n\n\n\n\nAfter you hit “OK” a new .Rmd script file will open in your top-left window with some template language and code chunks, similar to the image below. Alternatively, you can start from scratch by clicking “Create Empty Document” or open a template .Rmd file of your own saved on your computer.\n\n\n\nSave as .Rmd file. Save the file by going to “File -&gt; Save as” in RStudio\n\n\nGive the file an informative name like your LastnamePractice1.Rmd\n\n\nKey Components. Now you are ready to work within the Rmd script file. We will point to four basic components of this file, and you can build your knowledge of RMarkdown from there.\n\nThe top part bracketed by --- on top and bottom is the YAML component. This tells RStudio the pertinent information about how to “compile” the Rmd file.\n\nMost of the time you can leave this alone, but you can always edit the title, author, or date as you wish.\n\nThe next component are the global options for the document. It is conveniently labeled “setup.” By default what this is saying is that the compiled version will “echo” (i.e., display all code chunks and output) unless you specifically specify otherwise. For example, note that it says include = FALSE for the setup chunk. That setting means that this code chunk will “run” but it will not appear in the nicely compiled .html file.\n\nMost of the time you will not need to edit those settings.\n\nThe third component I want to bring attention to is the body text. The # symbol in RMarkdown is used to indicate that you have a new section of the document. For example, in the compiled images at the beginning, this resulted in the text being larger and bolded when it said “Problem 2.” In addition to just using a single #, using ## or ### can indicate subsections or subsubsections. Other than that symbol, you can generally write text just as you would in any word processing program, with some exceptions, such as how to make text bold or italicized.\nThe final component I want to call attention to are the other main body code chunks. These are specific parts of the document where you want to create a mini R script. To create these, you can simply click the + C symbol toward the top of the top left window of RStudio and indicate you want an R chunk.\n\n\n\n\nWriting R Code. Within a code chunk, you can type R code just like you would in any R script, as explained in the previous section. However, in RMarkdown, you also have the option of running an entire code chunk at once by hitting the green triangle at the top-right of a given code chunk.\n\n\n\nKnitting the document. Once you have added a code chunk and/or some text, you are ready to compile or “Knit” the document. This is what generates the .html document.\n\nTo do so, click on the Knit button toward the top of the top-left window of Rstudio. After a few moments, this should open up a preview window displaying the compiled html file.\nIt will also save an actual .html file in your working directory (the same location on your computer where you have saved the .Rmd file)\nTry to locate this compiled .html file on your computer and open it. For most computers, .html files will open in your default web browser, such as Google Chrome or Safari.\nThis step is a common place where errors are detected and generated. Sometimes the compiling process fails due to errors in the R code in your code chunks or an error in the Markdown syntax. If your document fails to knit, the next step is to try to troubleshoot the error messages the compiling process generates. The best way to reduce and more easily detect errors is to “knit as you go.” Try to knit your document after each chunk of code you create."
  },
  {
    "objectID": "index.html#optional-setup-short-assignment",
    "href": "index.html#optional-setup-short-assignment",
    "title": "Experiments 2024",
    "section": "Optional Setup Short Assignment",
    "text": "Optional Setup Short Assignment\nBelow is an exercise that will demonstrate you are able to use R as a calculator, create R scripts, and create and compile R Markdown files.\nYou will submit three documents on Canvas:\n\nAn R script (.R) file with your code. Follow the best practices by titling your script and using # comments to explain your steps. This code should be clean. I should be able to run your code to verify that the code produces the answers you write down.\nAn .Rmd document and a compiled RMarkdown .html document that you get after “knitting” the .Rmd file. This should also have a title including your name and use text or # comments to explain your steps.\n\nThis video provides a brief overview of opening an R script and R Markdown file in RStudio. The notes above provide additional details.\n\nOptional Assignment Exercises\n\nCreate a .R script saved as “LastnameSetup1.R” (use your last name). Within this file, make sure to title it and provide your name.\n\nSet your working directory, and include the file pathway (within setwd()) at the top of your .R script\nDo the calculation 8 + 4 - 5 in your R script. Store it as an object with an informative name. Report the answer as a comment # below the code.\nDo the calculation 6 x 3 in your R script. Store it as an object with an informative name. Report the answer as a comment # below the code.\nAdd these two calculations together. Note: do this by adding together the objects you created, not the underlying raw calculations. Report the answer as a # below the code.\n\nIn this problem, we will just re-format what we did in the first problem in an R Markdown format. Create a .Rmd R Markdown file saved as “LastnameSetup1.Rmd.” Within this file, make sure to title it and provide your name.\n\nCreate a Markdown heading # Problem 2.1. Underneath this, create an R code chunk in which you do the calculation 8 + 4 - 5. Store it as an object with an informative name. Report the answer in plain language below the code chunk.\nCreate a Markdown heading # Problem 2.2. Underneath this, create an R code chunk in which you do the calculation 6 x 3 in your R script. Store it as an object with an informative name. Report the answer in plain language below the code chunk.\nCreate a Markdown heading # Problem 2.3. Underneath this, create an R code chunk in which you add the previous two calculations together. Note: do this by adding together the objects you created, not the underlying raw calculations. Report the answer in plain language below the code chunk.\nCreate a Markdown heading # Problem 2.4. Write down how you will complete your R assignments this semester. For example, if you have a personal laptop with R and RStudio on it, you will simply write “I will use my personal laptop.” If you don’t have a personal computer or laptop, please indicate where on campus or off-campus you will have regular access to a computer with R/RStudio to do your work. It is essential that you have regular access to a computer so that you will not fall behind in this course.\n\nCreate a compiled .html file by “knitting” the .Rmd file into a .html document. Save the file as “LastnameSetup1.html.”\n\nAll done! Submit the three documents on Canvas."
  },
  {
    "objectID": "01-Experimentation.html#what-are-experiments",
    "href": "01-Experimentation.html#what-are-experiments",
    "title": "1  Why Experiment?",
    "section": "1.1 What are experiments?",
    "text": "1.1 What are experiments?\nOur first discussion will be focused on elaborating on what we see as the goals of social science and how experiments fit into these goals.\nWe draw on the following readings\n\nGerber, A. and D.P. Green. 2012. Field Experiments: Design, Analysis, and Interpretation. W.W. Norton. Chapter 1.\nAngrist, Joshua D. and Jorn-Steffen Pischke. Mostly Harmless Econometrics. Part One: Preliminaries: “Questions about Questions.” Available online here\nKinder, Donald R. and Thomas R. Palfrey. 1993. “On Behalf of an Experimental Political Science.” In Experimental Foundations of Political Science.\nSen, Maya and Omar Wasow. 2016. “Race as a Bundle of Sticks: Designs that Estimate Effects of Seemingly Immutable Characteristics.” Annual Review of Political Science doi: 10.1146/annurev-polisci-032015-010015.\n\nSkim one of the following for a more skeptical take on experiments/randomized controlled trials + Teele, Dawn. Field Experiments and Their Critics : Essays on the Uses and Abuses of Experimentation in the Social Sciences. New Haven: Yale University Press. Chapter 9 by Ian Shapiro or Chapter 2 by Susan Stokes + Stevenson, Megan. 2023. CAUSE, EFFECT, AND THE STRUCTURE OF THE SOCIAL WORLD. BU Law Review https://www.bu.edu/bulawreview/files/2023/12/STEVENSON.pdf\nWe will sketch out the answers to these questions as a group. Along the way, we will try to build a research design for a research question we come up with as a class.\n\nWhat are the goals of social science? What are examples of research questions that can be addressed with each goal?\n\nYour ideas …\n\nWhat makes an experiment an experiment? What are the goals of experimentation?\n\nYour ideas …\n\nWhat are some advantages of experimentation over other methods in political science?\n\nYour ideas …\n\nWhat are examples of different types of experiments?\n\nYour ideas …\n\nWhat are limitations of experiments? Can we experiment on everything?\n\nYour ideas …"
  },
  {
    "objectID": "01-Experimentation.html#getting-comfortable-with-r",
    "href": "01-Experimentation.html#getting-comfortable-with-r",
    "title": "1  Why Experiment?",
    "section": "1.2 Getting Comfortable with R",
    "text": "1.2 Getting Comfortable with R\nWe will use data from the article below, also provided as additional practice in section 2 of the course notes:\nThal, A. (2020). The desire for social status and economic conservatism among affluent Americans. American Political Science Review, 114(2), 426-442.\nThis study is an experiment where affluent Americans are randomly assigned to encounter Facebook posts in which others broadcast their economic success. These posts are designed in a way that encourages affluent respondents to view economic success as a means of achieving social status. The experiment includes a sample of 2010 affluent Americans– people who report household incomes in the top 10 percent of the U.S. income distribution.\n\nCausal Question: Does desire for social status influence economic views of affluent Americans?\nRandomization: Randomly assign respondents to view different fictional Facebook posts designed to signal different motivations\nOutcome: An economic conservatism index based on respondents’ support for decreasing “taxes on households making $150,000 or more a year,” support for decreasing the “taxes on money people make from selling investments, also referred to as capital gains,” and support for decreasing “government regulation of business and industry.”\nComparison: Average economic views between experimental conditions that vary in the type of social cues given.\n\n \n\n1.2.1 Dataframes in R\nKosuke Imai’s QSS Chapter 1.3.5 pgs. 20-25 discusses different ways to load data based on the file type.\n\nCommon file types include .csv, .RData, .dta (a Stata format), .sav (and SPSS format)\nYou want to match the function with the file type.\n\nFor .RData files, we can just use the load command. That function works the following way:\n\nload(\"status.RData\")\n\nAfter running the above code, an object will show up in your R environment.\n\nhead(status)\n\n        condition male   econcon\n2        Concrete    1 0.7500000\n3     Self-Esteem    1 1.0000000\n4         Placebo    1 0.6666667\n5     Self-Esteem    0 0.2500000\n6     Self-Esteem    0 1.0000000\n7 Social Approval    0 0.8333333\n\n\nWe also have a status.dta version of the file. To load this dataset, we could use the read.dta function which uses the library(foreign) package, a package uses for working with data types that are foreign to R.\n\nWhen working with a function from outside of “base R”– one that is located in a package, you always must open the package first using library() before using the function.\n\n\nlibrary(foreign)\nstatusdta &lt;- read.dta(\"status.dta\")\n\nIn addition to these dataset-specific functions, some people like to use the package rio which has a generic function import which can be used to load many file types.\n\nIf you do not have a package installed, the first time you use the package, you must first install it using install.packages(). By adding dependencies = T to this function, R will also automatically install any other packages that this package relies on to use.\n\n\ninstall.packages(\"rio\", dependencies=T)\n\n\nlibrary(rio)\nstatusrio &lt;- import(\"status.dta\")\n\nWe also have a status.csv file type. We can use read.csv() to load this file.\n\nstatuscsv &lt;- read.csv(\"status.csv\")\n\nAs an alternative, some people prefer to use the read_csv function that comes from the tidyverse package readr.\n\nIf you get an error saying you haven’t installed tidyverse, follow what we did above in installing the rio package, but this time, for tidyverse.\n\n\nlibrary(tidyverse)\nstatuscsv2 &lt;- read_csv(\"status.csv\")\n\nYOUR TURN: Not that we could also use import() to load the .csv version of the file. You can try that now:\n\n## Use import to load the csv file\n## Note: remember to use the appropriate library command\n\nEach of these processes will load an object in your R environment.\n\nNote that there may be minor differences in how the data load depending on the function used. For example, some may include an extra indexing variable with a unique number per row.\nIn addition, there may be differences in the class() of how a variable loads.\n\n\nLet’s explore the data.\n\nWe can view the data in a separate window using the View() command\n\n\nView(status)\n\n\n\nNote that the top of each column is a header with a variable name.\nThes variable names “belong” to the dataframe object status\n\nThat is, status is a dataframe, which means it has rows and columns.\n\nIn our case, every row represents a different survey respondent.\nThe corresponding values in each column represent the values a given respondent takes on a different variable in the dataset. For example, the respondent in the 8th row was in the Self-Esteem condition, took the value 1 on male, and the value .4166 on econcon.\n\n\nclass(status)\n\n[1] \"data.frame\"\n\n\nWe have three primary columns or “variables” or “vectors” in our data.\n\ncondition: Placebo, Concrete, Self-Esteem, Social Approval, Conspicuous Consumption\nmale: 1= male; 0= otherwise\neconcon: Economic views. Numeric variable from 0 to 1, with higher values reflecting more conservative views\n\nTo access a column name that exists within a dataframe (i.e., the column condition exists within the dataframe status), we generally use the syntax of the dataframename$columnname. The dataframe name is on the left of the dollar sign, and the column name is on the right.\nTo access the values of the condition column, we type:\n\nstatus$condition\n\nYOUR TURN: access the values in the econcon column.\n\n## Access the values in the econcon column\n\n\n\n1.2.2 Computing summary statistics of variables\nThis syntax (dataframename$columnname) applies when we want to compute summary statistics of specific columns within data frames.\nR has a number of functions (See QSS chapter 1.3.4) that can be used to summarize columns aka vectors.\n\nExamples: mean(), median(), range(), sd(), length(), table()\n\nTo apply these to a column within our dataframe, we similarly have to follow the syntax dataframename$columnname inside our function. For example, to find the range of the econcon variable, we write:\n\nrange(status$econcon)\n\n[1] 0 1\n\n\nYOUR TURN: Find the mean of this column.\n\n## Find the mean of the econcon column\n\nIn the real world, often our data include missing values, which R represents as an NA. When this happens, we add an argument to these common functions, na.rm=T which tells R to “remove” / ignore the NA values when computing the mean, range, standard deviation, etc. Not all functions allow this argument, so if you receive an error when trying to use it, it could be that the argument doesn’t work for that particular function\n\nrange(status$econcon, na.rm=T)\n\n[1] 0 1\n\n\nNot all functions allow this argument, so if you receive an error when trying to use it, it could be that the argument doesn’t work for that particular function. For example, the code below will generate an error because table() doesn’t have this argument.\n\ntable(status$econcon, na.rm=T)\n\nA common tool we may use to summarize variables is also the table() command, which will tell you how many observations (survey respondents) take on a particular value of a variable. Example:\n\ntable(status$condition)\n\n\n                Placebo                Concrete Conspicuous Consumption \n                    394                     391                     392 \n            Self-Esteem         Social Approval \n                    390                     375 \n\n\nWe see, for example, that 394 respondents were in the Placebo experimental condition.\nYOUR TURN: Use table on the male column and indicate how many males and females we have in the data.\n\n## Use the table command to indicate how many male and female respondents\n\n\n\n1.2.3 Relational operators\nIn experiments, we often don’t want to know these summary statistics for all respondents. Instead, often we want to know the summary statistics separately for those that belong to different subgroups of the sample.\nWe can use relational operators to help us isolate particular subgroups of data when conducting our analysis. We have several relational operators in R that evaluate logical statements:\n\n==, &lt;, &gt;, &lt;=, &gt;=, !=\nWe have a statement and R evaluates it as TRUE or FALSE\nNote that relational operators use a double == to evaluate logical equivalency. This is different from the single = that is sometimes used elsewhere in R, such as in arguments within functions (.eg., na.rm = T)\n\n\n## for each observation, does the value of condition equal \"Self-Esteem\"?\nstatus$condition == \"Self-Esteem\"\n\nFor some values, it returns TRUE because a respondent was in that condition. For others, it returns FALSE because a respondent was in a different condition.\n\nNote that R is very sensitive, including case sensitive. You want to make sure you enter the values (e.g., “Self-Esteem”) EXACTLY as they appear in the dataframe. Extra spaces, typos, wrong capitalization will all give you the wrong answer.\nNote that we use quotations around “Self-Esteem” because it is text. If instead we had a logical statement involving a numeric value, we would not need quotes.\n\n\nstatus$male == 1\n\nYOUR TURN: Use a logical statement to evaluate whether a given respondent takes the value “Placebo” as the condition variable.\n\n## Does condition equal Placebo?\n\nBy putting this logical statement within [ ], we are asking R to take the mean() of the variable staus$econ for the subset of observations for which a logical statement is TRUE.\n\nLet’s take the overall mean of the econcon variable\nThis represents the average economic conservatism for all respondents\n\n\nmean(status$econcon, na.rm=T)\n\n[1] 0.6633625\n\n\n\nLet’s take the mean of the econcon variable for those in the “Social Approval” condition (status$condition == \"Social Approval\")\nThis represents the average economic conservatism for respondents in the Social Approval condition\n\n\nmean(status$econcon[status$condition == \"Social Approval\"], na.rm=T)\n\n[1] 0.6904444\n\n\nYour TURN: Compare this to the mean of those in the Placebo condition.\n\n## Find the mean econcon for those in the Placebo condition\n\n\n1.2.3.1 Adding Boolean operators to relational statements\nInstead of a single relational statement, sometimes we may want to combine multiple relational operators into a single logical statement.\nFor example, we may want to find the average economic views for male respondents, only, in the social approval condition. We need to find those that are in the Social Approval condition and are male.\n\nIn R, we can use & and | to represent AND and OR statements\n\nFor example, this will evaluate the logical statement asking if a respondent is in the Social Approval condition AND is male.\n\nstatus$condition == \"Social Approval\" & status$male == 1\n\nFor example, this will evaluate the logical statement asking if a respondent is in the Social Approval condition OR the Placebo condition.\n\nstatus$condition == \"Social Approval\" | status$condition == \"Placebo\"\n\nJust like before, we can embed this entire statement into our [] to isolate these respondents when calculating descriptive statistics, such as average economic conservatism for these respondents.\n\nmean(status$econcon[status$condition == \"Social Approval\" \n                    & status$male == 1], na.rm=T)\n\n[1] 0.733631\n\n\nYOUR TURN: Find the average economic conservatism for respondents who are either in the Social Approval or Placebo conditions.\n\n### Mean econcon for respondents in Social Approval or Placebo condition\n\n\n\n1.2.3.2 Storing calculations as objects\nFor any of these calculations, you can store them as objects in your R environment by using the &lt;- assignment tool. You will always write the object name you desire to the left of this tool, and keep the calculations on the right.\n\nStoring these calculations can be useful because instead of needing to remember the raw number, you can just write the object name to retrieve the calculation.\n\nFor example we could save the mean economic views for respondents in the Social Approval condition as an object meanSocApp\n\nYou can name objects pretty much anything. You just want them to be relatively short, informative, and try to avoid special characters or words that have some other meaning in R (Example: you wouldn’t want to name an object range because that is already a function name in R.)\n\n\nmeanSocApp &lt;- mean(status$econcon[status$condition == \"Social Approval\"],\n                   na.rm=T)\nmeanSocApp\n\n[1] 0.6904444\n\n\nOnce you create an object, it should also show up in your R environment.\n\nLet’s do the same for the Placebo and Concrete conditions.\n\nmeanPlacebo &lt;- mean(status$econcon[status$condition == \"Placebo\"],\n                   na.rm=T)\nmeanPlacebo\n\n[1] 0.6340948\n\n\n\nmeanConcrete &lt;- mean(status$econcon[status$condition == \"Concrete\"],\n                   na.rm=T)\nmeanConcrete\n\n[1] 0.6647485\n\n\n\n\n\n1.2.4 Subsetting Dataframes\nThus far, we have used relational operators and boolean statements to isolate values within particular columns of a dataframe. We might also just want to simply cut down our whole dataframe (e.g., status) and create a new dataframe that contains only those rows relevant to a particular group of respondents.\n\nIn subsetting an entire dataframe, we retain all of the columns in the dataframe. (I.e., we will still have the columns condition, male and econcon). However, we will have a smaller number of rows.\n\nFor example, perhaps the researcher was interested in how the experiment worked for only respondents who are male. If we know we are going to conduct all of our analyses just on male respondents, it could be efficient for us to create a new, smaller dataframe that only includes rows where a respondent is male.\nTo do this, we will use the subset R command. It has the syntax newdataframe &lt;- subset(existingdataframe, logicalstatement). For example, let’s create a new dataframe maleonly that contains the rows from the existing dataframe status where male == 1, reflecting that a respondent is male.\n\nNote: In this function, we deviate from our previous syntax of using dataframe$columnname. This is because in the first argument, we tell R in which dataframe our columns are located.\n\n\nmaleonly &lt;- subset(status, male ==1)\n\nNote that this creates a new dataframe object in our environment. It just has a smaller number of observations (rows), reflecting that not all of our sample was male.\n\nWe can view this new dataframe using the same View() command as before.\n\nView(maleonly)\n\n\nNote that it looks very similar to the original status dataframe, but now all of the values in the male column are 1.\nWe can treat this new dataframe the same way as status going forward, in that we can use the maleonly$columnname syntax to summarize columns within the maleonly dataframe. For example, maleonly$econcon would represent the values that male respondents take on economic conservatism.\nYour TURN: Using the new dataframe, find the average economic conservatism for male respondents.\n\n## Using maleonly dataframe, find mean economic conservatism\n\n\n## Note the value's equivalence to\nmean(status$econcon[status$male == 1], na.rm=T)\n\n[1] 0.69486\n\n\nSubsetting data can be an efficient way to write code to avoid the need to repeat relational operators within functions when computing summary statistics. For example, in the first problem set, you may subset your data to include only people that prefer to watch Entertainment, another subset for those who prefer to watch Fox, and so on.\n\n\n1.2.5 Working outside of dataframes\nWhile much of our work in analyzing social science studies will exist within our dataframe objects, there are times where we may construct our own sets of objects that exist outside of dataframes.\nFor example, we created meanConcrete, meanPlacebo, and meanSocApp objects.\n\nThese represent the average economic conservatism for respondents in the Concrete, Placebo, and Social Approval conditions.\n\nTo retrieve each of these values, we could type them separately:\n\nmeanConcrete\n\n[1] 0.6647485\n\nmeanPlacebo\n\n[1] 0.6340948\n\nmeanSocApp\n\n[1] 0.6904444\n\n\nHowever, to be more efficient, we could also bind them together in a single object using the c() function. This function creates a vector.\n\nconditionmeans &lt;- c(meanConcrete, meanPlacebo, meanSocApp)\nconditionmeans\n\n[1] 0.6647485 0.6340948 0.6904444\n\n\nNow, to retrieve the means for all of these conditions, we can simply type and run conditionmeans.\nNote: Because conditionmeans does not exist within a dataframe, we don’t need a $ to access it. This is in contrast to a vector like econcon which solely exists within the dataframes status or maleonly.\nBinding together values can come in handy when writing up reports of an analysis or even for visualization.\nWhile we won’t go into detail on plotting in this session, we can see an example of plotting these three condition means at points 1,2, and 3 on a simple point-based plot() in R.\n\nplot(x = c(1,2,3),\n     y = conditionmeans)\n\n\n\n\nWe can spice up the plot with some aesthetics to make it more readable:\n\nplot(x = c(1,2,3),\n     y = conditionmeans,\n     xlim = c(.5, 3.5),\n     ylim=c(.6, .75),\n     xlab= \"Experimental Condition\",\n     ylab= \"Mean Economic Conservatism\",\n     main = \"Economic conservatism by condition\",\n     xaxt=\"n\")\naxis(1, c(1,2,3), c(\"Concrete\", \"Placebo\", \"Social\\n Approval\"),\n     tick=F)\n\n\n\n\nHow did seeing a message about social approval influence economic attitudes?"
  },
  {
    "objectID": "02-CausalEffects.html#potential-outcomes-framework",
    "href": "02-CausalEffects.html#potential-outcomes-framework",
    "title": "2  Causal Effects",
    "section": "2.1 Potential Outcomes Framework",
    "text": "2.1 Potential Outcomes Framework\nTo make causal claims, we compare two states of the world and their potential outcomes:\n\\(Y_i(d)\\)\n\nWhat is \\(Y_i(0)\\)?\nWhat is \\(Y_i(1)\\)?\n\n\\(i\\) refers to individual subjects from \\(i = 1\\) to N.\n\\(d\\) is the treatment indicator\n\\(d_i\\) refers to whether the subject is treated: \\(d_i = 1\\) or \\(d_i = 0\\)\n\\(D_i\\) refers to a hypothetical treatment allocation\n\n\nA causal “treatment effect” is then the difference in these potential outcomes:\n\n\\(\\tau_i\\) = \\(Y_i(1)\\) - \\(Y_i(0)\\)\n\n FEDAI Table 2.1\nThe treatment effect is the difference between two states of the world: one which a unit receives treatment, and another in which it does not.\n\n2.1.1 Average Treatment Effect\nThe average treatment effect then is the mean of these individual treatment effects:\n\nEstimand: On average, how much outcomes would change if all units go from untreated to treated.\n\n\\[\\begin{align*}\nATE &= \\frac{1}{N} \\sum_{i=1}^N \\tau_i \\\\\n&= \\mu_{Y(1)} -\\mu_{Y(0)} \\\\\n&= \\frac{1}{N} \\sum_{i=1}^N Y_i (1) - \\frac{1}{N} \\sum_{i=1}^N Y_i (0) \\\\\n&= \\frac{1}{N} \\sum_{i=1}^N (Y_i (1)-Y_i (0))\\\\\n&= E[Y_i(1) - Y_i(0)]\\\\\n\\end{align*}\\]\nATE \\(= \\frac{1}{N} \\sum_{i=1}^N \\tau_i\\) is what we want to describe a causal effect, but in real life, we have problems. What are they?\n\n\nTry on your own, then expand for the answer.\n\nWe only observe one potential outcome.\n\n\\(Y_i = d_iY_i(1) + (1-d_i)Y_i(0)\\)\n\n(Unless we are in Groundhog Day)"
  },
  {
    "objectID": "02-CausalEffects.html#fundamental-problem-of-causal-inference",
    "href": "02-CausalEffects.html#fundamental-problem-of-causal-inference",
    "title": "2  Causal Effects",
    "section": "2.2 Fundamental Problem of Causal Inference",
    "text": "2.2 Fundamental Problem of Causal Inference\nWe only observe one potential outcome: \\(Y_i\\).\n\n\\(Y_i = d_iY_i(1) + (1-d_i)Y_i(0)\\)\n\n(Unless we are in Groundhog Day)\nThe fundamental problem of causal inference is that we can only observe one potential outcome, the outcome in this case, under the state of the world \\(Y_i(0)\\) where the play unfolded as it did in the video.\n\nIt is impossible to observe the actual causal effect of any of the above: \\(Y_i(1) -Y_i(0)\\)"
  },
  {
    "objectID": "02-CausalEffects.html#identification-strategy",
    "href": "02-CausalEffects.html#identification-strategy",
    "title": "2  Causal Effects",
    "section": "2.3 Identification strategy",
    "text": "2.3 Identification strategy\nWe cannot observe the ideal actual causal effect. Instead, we will frame our exercise on the premise that we are randomly sampling our \\(i's\\) from a population. We then will create an identification strategy.\n\n“Ideas that enable researchers to use observable quantities (e.g., sample averages) to reveal parameters of interest (e.g., average treatment effects)” (Gerber and Green 2012, 34)\nInstead of observing the actual individual causal treatment effect and actual ATE, we develop an estimator for this quantity using the sample averages.\n\nA few definitions:\n\nThe sample average is a random variable, a quantity that varies from sample to sample.1\nExpected value is the average outcome of a random variable weighted by its probability of occurrence.\nGood news: Under random sampling, the expected value of a sample average is the population average.\nSimilarly, the expectation of a randomly selected observation from the population is the population mean.\nEven though we have a sample, under random sampling, our sample will be unbiased. On average, it’s true.\n\nWhen the expected value of a sample estimate is equal to the population parameter \\(E[\\hat{\\theta}] = \\theta\\), this means our estimator is “unbiased.”\n\n\nExpectation\n\\[\\begin{align*}\nE[X]=\\sum x Pr[X=x]\n\\end{align*}\\]\n\nwhere \\(Pr[X=x]\\) denotes the probability that \\(X\\) takes on the value \\(x\\), and where the summation is taken over all possible values of \\(x\\). Think of this like a weighted average.\n\nExample: \\(E[Y_i(1)]\\) is the expected value of the treated potential outcome of a subject who is randomly sampled.(It will equal the average value of all possible values.)\n\nWhat is the value of \\(E[Y_i(1)]\\) in this example?\n\n FEDAI Table 2.1"
  },
  {
    "objectID": "02-CausalEffects.html#difference-in-means-estimator",
    "href": "02-CausalEffects.html#difference-in-means-estimator",
    "title": "2  Causal Effects",
    "section": "2.4 Difference in Means Estimator",
    "text": "2.4 Difference in Means Estimator\nIn the real world, we follow this process for causal identification:\n\nOur motivation: Find quantities that represent the population parameters (\\(\\theta\\))\nOur problem: We often only get a sample of the population and can only observe one potential outcome for any unit in our sample\nGoal: Get unbiased estimators for the population\nDefinition of unbiasedness: \\(E[\\hat{\\theta}] = \\theta\\)\n\nSuppose \\(D_i\\) were randomly assigned such that \\(m\\) subjects assigned to treatment and \\(N-m\\) subjects assigned to control.\n\\[\\begin{align*}\n\\widehat{ATE} &= \\frac{1}{m}\\sum_1^m Y_i - \\frac{1}{N-m}\\sum_{m+1}^{N} Y_i \\\\\n\\end{align*}\\]\nIs the difference in means estimator an unbiased estimate for the ATE? How can we find out?\nWe take the expected value:\n\\[\\begin{align*}\nE[\\widehat{ATE}] &= E[\\frac{1}{m}\\sum_1^m Y_i - \\frac{1}{N-m}\\sum_{m+1}^{N} Y_i ]\\\\\n&= \\frac{1}{m}\\sum_1^m E(Y_i) - \\frac{1}{N-m}\\sum_{m+1}^{N} E(Y_i ) \\\\\n&= \\frac{E(Y_1) + E(Y_2) +...+E(Y_m)}{m} -  \\frac{E(Y_{m+1}) + E(Y_{m+2}) +...+E(Y_N)}{N-m}\\\\\n&= \\frac{m * E[Y_i(1 | D_i = 1)]}{m} - \\frac{(N-m)* E[Y_i(0) | D_i = 0]}{N-m}\\\\\n&= E[Y_i(1) | D_i = 1] - E[Y_i(0) | D_i = 0] \\\\\n%&= E[Y_i (1)]-E[Y_i (0)]=E[\\tau_i ]=ATE\n\\end{align*}\\]\nIs the final statement equivalent to the ATE?\n\nWe want our final statement to be \\(E[Y_i (1)]-E[Y_i (0)]=E[\\tau_i ]\\)=ATE\nOur final statement is: \\(E[Y_i(1) | D_i = 1] - E[Y_i(0) | D_i = 0]=E[\\widehat{ATE}]\\)\n\nUnder what conditions can we get those two statements to look the same?\n\n\nWell, let’s look into some rules of expectation.\n\n\\(E[Y|X] = E[Y]\\) if Y and X are independent.2\n\nOur final statement can be simplified when treatment assignment is independent of potential outcomes:\n\n\\(E[Y_i(1) |D_i = 1] = E[Y_i(1) |D_i = 0] = E[Y_i(1)]\\)\n\\(E[Y_i(0) |D_i = 0] = E[Y_i(0) |D_i = 1] = E[Y_i(0)]\\)\n\nWhen does this occur? Random assignment of treatment!!\nPutting this together, under random assignment:\n\\[\\begin{align*}\nE[\\widehat{ATE}] &= E[\\frac{1}{m}\\sum_1^m Y_i - \\frac{1}{N-m}\\sum_{m+1}^{N} Y_i ]\\\\\n&= \\frac{1}{m}\\sum_1^m E(Y_i) - \\frac{1}{N-m}\\sum_{m+1}^{N} E(Y_i ) \\\\\n&= E[Y_i(1) | D_i = 1] - E[Y_i(0) | D_i = 0] \\\\\n&= E[Y_i (1)]-E[Y_i (0)]=E[\\tau_i ]\\\\\nE[\\widehat{ATE}] &= ATE\n\\end{align*}\\]\nWhy Experiments\nOne approach for addressing the fundamental problem of causal inference is to simulate two potential states of the world through random assignment: Randomized Controlled Trials / Experiments\nExperiments approximate factual vs. counterfactual comparison\n\nWe randomly assign one group to receive a “treatment” and another not to receive a treatment (the control)\nUsing what we learned above, when treatment assignment is randomized, the only thing that distinguishes the treatment group from the control group in expectation, besides the treatment itself, is chance.\nThis allows us to use a simple differences in means estimator in experiments to estimate our average treatment effects."
  },
  {
    "objectID": "02-CausalEffects.html#overview-of-identification-assumptions",
    "href": "02-CausalEffects.html#overview-of-identification-assumptions",
    "title": "2  Causal Effects",
    "section": "2.5 Overview of identification assumptions",
    "text": "2.5 Overview of identification assumptions\nWhat if we can’t guarantee random assignment?\nExample: Selection into treatment\nWhat if we didn’t have the independence? Subtract and add \\(E[Y_i (0) | D_i=1]\\) to help us illustrate a type of bias that may occur.\n\\(E[Y_i (1) | D_i=1]-E[Y_i (0) | D_i=0] =\\)\n\\(\\underbrace{E[Y_i (1) | D_i = 1] - E[Y_i (0) | D_i=1]}_{\\text{Average treatment effect for the treated}} + \\underbrace{E[Y_i (0)|D_i=1]-E[Y_i (0)| D_i=0] }_{\\text{Selection bias}}\\)\nIn observational studies, where assignment into treatment is not random, the second term “Selection bias” may not be zero.\n\nE.g., suppose we want to know the effect of minimum wage laws on unemployment.\nLaws aren’t randomly assigned\nPossible that states where unemployment (outcome) is lower are less likely to see minimum wage laws passed relative to states where unemployment is higher. If so, the potential outcomes \\(Y_i(0)\\) of states that would hypothetically be treated or untreated would not be the same.\n\nAssumptions\nTo “identify” the average treatment effect, we need\n\nProbability of treatment of all units is between 0 and 1\nIgnorability: \\(Y_i(1), Y_i(0) \\perp D_i\\) (random assignment)\nNon-interference: \\(Y_i(d_1, d_2, ..., d_n) = Y_i(d)\\), \\(d_i = d\\)\nExcludability: if \\(Y_i(z, d)\\) where z \\(\\in [0, 1]\\) and \\(d \\in [0, 1]\\), \\(Y_i(1, d) = Y_i(0, d)\\)\n\nLet’s put these into plain words."
  },
  {
    "objectID": "02-CausalEffects.html#application-in-r",
    "href": "02-CausalEffects.html#application-in-r",
    "title": "2  Causal Effects",
    "section": "2.6 Application in R",
    "text": "2.6 Application in R\nArticle: “Are Emily and Greg More Employable Than Lakisha and Jamal? A Field Experiment on Labor Market Discrimination” by Bertrand and Mullainathan (2004)\n\nResearch Question: Does race influence hiring decisions?\nWhat are the potential outcomes?\nWhat is the approach? Audit study: “send fictitious resumes to help-wanted ads in Boston and Chicago newspapers.\n\nTreatment: Manipulate perceived race: resumes randomly assigned African-American- or White-sounding names.\nOutcomes: Does the resume get a callback?\n\n\nHow should we estimate the average treatment effect?\n\n2.6.1 Loading the data\nWe will use data from Imai (2017) Chapter 2.\nLet’s load the data. Note: When we have variables that are text-based categories, we may want to tell R to treat these “strings” of text information as factor variables, a particular type of variable that represents data as a set of nominal (unordered) or ordinal (ordered) categories. We do this with the stringsAsFactors argument.\n\nresume &lt;- read.csv(\"resume.csv\", stringsAsFactors = T)\n\n\nresume &lt;- read.csv(\"https://raw.githubusercontent.com/ktmccabe/teachingdata/main/resume.csv\",\n                   stringsAsFactors = T)\n\nVariables and Description\n\nfirstname: first name of the fictitious job applicant\nsex: sex of applicant (female or male)\nrace: race of applicant (black or white)\ncall: whether a callback was made (1 = yes, 0 = no)\n\nThe data contain 4870 resumes and 4 variables.\n\nnrow(resume) # number of rows\n\n[1] 4870\n\nncol(resume) # number of columns\n\n[1] 4\n\ndim(resume) # number of rows and columns\n\n[1] 4870    4\n\n\n\nhead(resume)\n\n  firstname    sex  race call\n1   Allison female white    0\n2   Kristen female white    0\n3   Lakisha female black    0\n4   Latonya female black    0\n5    Carrie female white    0\n6       Jay   male white    0\n\n\n\n\n2.6.2 Variable classes\nWe can check the class of each variable: Look, we have a new type, a “factor” variable.\n\nclass(resume$firstname)\n\n[1] \"factor\"\n\nclass(resume$sex)\n\n[1] \"factor\"\n\nclass(resume$race)\n\n[1] \"factor\"\n\nclass(resume$call)\n\n[1] \"integer\"\n\n\nRules of Thumb\n\nUsually, we want character variables to store text (e.g., open-ended survey responses)\nWe want numeric variables to store numbers.\nUsually, we want factor variables to store categories.\n\nWithin R, factor variables assign a number to each category, which is given a label or level in the form of text.\nCategories might be ordinal or “ordered” (e.g., Very likely, Somewhat likely, Not likely) or\nUnordered (e.g., “male”, “female”)\nR won’t know if a factor variable is ordered or unordered. Alas, we have to be smarter than R.\nR might think you have a character variable when you want it to be a factor or the reverse.\n\nThat’s when as.factor() and as.character() are useful.\n\n\nAlways check class() to find out the variable type\n\n\n\n2.6.3 Exploring Treatment and Control Groups\nWe are going to use several different approaches to calculate our difference in means between treatment and control to help us explore R’s capabilities and common computational approaches.\nWe can use the table command to see how many observations in our data fall into each category or numerical value.\n\n## Example: how many black vs. white sounding resumes\ntable(resume$race)\n\n\nblack white \n 2435  2435 \n\n\nAs mentioned, factor variables have levels:\n\nlevels(resume$race)\n\n[1] \"black\" \"white\"\n\n\nWe can also use the table command to show a crosstabulation: a table that displays the frequency of observations across two variables. Because our outcome variable call is dichotomous and we are interested in the rates of callbacks, we might use a table to display this information. (For outcomes that are continuous, the table approach is less useful.)\n\n## Example: how many black vs. white sounding resumes by call backs\n## We can label the two dimensions of the table with the =\ntable(calledback = resume$call, race = resume$race)\n\n          race\ncalledback black white\n         0  2278  2200\n         1   157   235\n\n\nSometimes we will want to show the proportion instead of the frequency using prop.table\n\n## Example: proportion black vs. white sounding resumes by call backs\n## Convert to proportion\nprop.table(table(calledback = resume$call, race = resume$race), margin = 2) # 1 for row sum, 2 for col\n\n          race\ncalledback      black      white\n         0 0.93552361 0.90349076\n         1 0.06447639 0.09650924\n\n\nHow can we interpret this crosstabulation?\n\n\n2.6.4 Means with Relational Operators\nGoal: Compare callback rates for white sounding names to black sounding names, so we need to be able to filter by race.\nGood news: We have several relational operators in R that evaluate logical statements:\n\n==, &lt;, &gt;, &lt;=, &gt;=, !=\nWe have a statement and R evaluates it as TRUE or FALSE\n\n\n## for each observation, does the value of race equal \"black\"?\nresume$race == \"black\"\n\nBy putting this logical statement within [ ], we are asking R to take the mean() of the variable resume$call for the subset of observations for which this logical statement is TRUE.\n\nmean(resume$call[resume$race == \"black\"])\n\n[1] 0.06447639\n\n\nUltimately, each of these paths has led us to a place where we can estimate the average treatment effect by calculation the difference in means: the difference in callback rates for black and white applicants.\nWe said the ATE = \\(\\bar{Y}(treatment) - \\bar{Y}(control)\\)\n\nate &lt;- mean(resume$call[resume$race == \"black\"]) - \n  mean(resume$call[resume$race == \"white\"])\nate\n\n[1] -0.03203285\n\n\nHow can we interpret this? Do white applicants have an advantage?\n\n\n2.6.5 Means with tidyverse\nThe tidyverse offers a suite of R functions and a different grammar or syntax of coding. Some people prefer this to the “base R” codes we did above. To use this suite, first install the tidyverse package:\nWhen you install a package, this is like downloading an app to your phone. You only have to do it one time.\n\ninstall.packages(\"tidyverse\")\n\nAfter you have a package installed, much like an app on your phone, you then need to open it before using it in R. To do so, use the library() command.\n\nlibrary(tidyverse)\n\nThe tidyverse works through these piping %&gt;% operators. We can read it from left to right. Take our dataset resume, group the data by race, and within each racial group, summarize the data by taking the mean call back rate.\n\nresume %&gt;%\n  group_by(race) %&gt;%\n  summarise(means = mean(call))\n\n# A tibble: 2 × 2\n  race   means\n  &lt;fct&gt;  &lt;dbl&gt;\n1 black 0.0645\n2 white 0.0965\n\n\nWe could go a step further to calculate the ATE.\n\nate &lt;- resume %&gt;%\n  group_by(race) %&gt;%\n  summarise(means = mean(call)) %&gt;%\n  ungroup() %&gt;%\n  spread(race, means)%&gt;%\n  mutate(diff = black - white)\n\nate\n\n# A tibble: 1 × 3\n   black  white    diff\n   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;\n1 0.0645 0.0965 -0.0320\n\n\n\n\n2.6.6 ATE with linear regression\nLinear regression also offers a way to calculate the conditional means and difference in means between two groups. In R, we use lm() for this. The syntax is lm(y ~ x, data = mydataframe).\n\nfit &lt;- lm(call ~ race, data =resume)\n\nWe can look at the coefficient results only.\n\nfit$coefficients\n\n(Intercept)   racewhite \n 0.06447639  0.03203285 \n\n\nIn a regression of this form, the intercept represents the mean of the reference category, in this case, the callback rate for Black applicants. The coefficient on racewhite represents the difference in means between the reference category and this group. I.e., going from a Black applicant (the reference category) to a white applicant, on average, increases call backs by 3.2 percentage points.\n\n\n2.6.7 Subsetting data in R\nMaybe we are interested in differences in callbacks for females. One approach for looking at the treatment effect for female applicants, only, is to subset our data to include only female names.\n\nTo do this, we will assign a new data.frame object that keeps only those rows where sex == \"female\" and retains all columns\nBelow are two approaches for this subsetting, one that uses brackets and one that uses the subset function\n\n\n## option one\nfemales &lt;- resume[resume$sex == \"female\", ]\n## option two using subset()- preferred\nfemales &lt;- subset(resume, sex == \"female\")\n\nNow that we have subset the data, this simplifies estimating the ATE for female applicants only.\nWe said the ATE = \\(\\bar{Y}(treatment) - \\bar{Y}(control)\\)\n\nate.females &lt;- mean(females$call[females$race == \"black\"]) -\n  mean(females$call[females$race == \"white\"])\nate.females\n\n[1] -0.03264689\n\n\nQuestion: Is this an unbiased estimate of the average treatment effect?\n\n\nTry on your own, then expand for the answer.\n\nThis is an example of a “Conditional Average Treatment Effect.” Generally, because gender is a pre-treatment factor, we can condition on it and get unbiased estimates for the average treatment effect within a particular gender group.\n\nRandom assignment of treatment means that in expectation, we should have about equal proportions of female applicants in each treatment group, ruling out the potential for selection bias.\n\n\n\n\n2.6.8 Additional Practice\nWe will use data from the article below:\nThal, A. (2020). The desire for social status and economic conservatism among affluent Americans. American Political Science Review, 114(2), 426-442.\nIn the experiment, affluent Americans are randomly assigned to encounter Facebook posts in which others broadcast their economic success. These posts are designed in a way that encourages affluent respondents to view economic success as a means of achieving social status. The experiment includes a sample of 2010 affluent Americans– people who report household incomes in the top 10 percent of the U.S. income distribution.\n\nCausal Question: Does desire for social status influence economic views of affluent Americans?\nRandomization: Randomly assign respondents to view different fictional Facebook posts designed to signal different motivations\nOutcome: An economic conservatism index based on respondents’ support for decreasing “taxes on households making $150,000 or more a year,” support for decreasing the “taxes on money people make from selling investments, also referred to as capital gains,” and support for decreasing “government regulation of business and industry.”\nComparison: Average economic views between experimental conditions that vary in the type of social cues given.\n\n\n\nLet’s load the data! Here, note that the data file is in a .RData format instead of .csv. This means that instead of using read.csv, we should use a function to load the data that is suitable for the .RData format. This will be load. That function works the following way:\n\nload(\"status.RData\")\n\nAfter running the above code, an object will show up in your R environment.\n\nhead(status)\n\n        condition male   econcon\n2        Concrete    1 0.7500000\n3     Self-Esteem    1 1.0000000\n4         Placebo    1 0.6666667\n5     Self-Esteem    0 0.2500000\n6     Self-Esteem    0 1.0000000\n7 Social Approval    0 0.8333333\n\n\nThe data include the following variables\n\ncondition: Placebo, Concrete, Self-Esteem, Social Approval, Conspicuous Consumption\nmale: 1= male; 0= otherwise\neconcon: Economic views. Numeric variable from 0 to 1, with higher values reflecting more conservative views\n\nPractice:\n\nHow many people are in each condition?\nWhat is the average treatment effect between the Placebo and Social Approval conditions?\n\n\n\nTry on your own, then expand for the answer.\n\n\n## Number of observations\ntable(status$condition)\n\n\n                Placebo                Concrete Conspicuous Consumption \n                    394                     391                     392 \n            Self-Esteem         Social Approval \n                    390                     375 \n\n## tidy\ngroupmeans &lt;- status %&gt;%\n  group_by(condition) %&gt;%\n  summarise(means = mean(econcon)) %&gt;%\n  ungroup %&gt;%\n  spread(condition, means) \ngroupmeans$`Social Approval` - groupmeans$Placebo\n\n[1] 0.05634969\n\n## relational operators\nate &lt;- mean(status$econcon[status$condition == \"Social Approval\"]) - mean(status$econcon[status$condition == \"Placebo\"]) \nate\n\n[1] 0.05634969\n\n## regression\nfit &lt;- lm(econcon ~ condition, data = status)\nfit$coefficients[\"conditionSocial Approval\"]\n\nconditionSocial Approval \n              0.05634969 \n\n\n\nAdditional Review Questions\n\nWhat is this quantity \\(E[Y_i (1) − Y_i (0)]\\) conceptually?\nWhat is the fundamental problem of causal inference?\nHow can we find out if our estimates are unbiased? (What process do we need to do?)\nWith randomization, why is \\(E[Y_i (1)] = E [Y_i (1)|D_i = 1]\\)?\nWhat other assumptions do we need to estimate the ATE in an unbiased way using differences in means?"
  },
  {
    "objectID": "02-CausalEffects.html#footnotes",
    "href": "02-CausalEffects.html#footnotes",
    "title": "2  Causal Effects",
    "section": "",
    "text": "Note: other books may approach this slightly differently by defining a Sample ATE, taking \\(D_i\\) (treatment status) to be the random variable, and \\(Y_i(1)\\) as fixed within a sample.↩︎\nSee video for help on law of iterated expectations↩︎"
  }
]